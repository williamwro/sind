(function (d) {"function" === tipo de definir && define.amd? define (["jquery", "datatables.net"], função (l) {retorna d (l, janela, documento)}): "objeto "= tipo de exportação? module.exports = função (l, j) {l || (l = janela); if (! j ||! j.fn.dataTable) j = require (" datatables.net ") (l, j). $; return d (j, l, l.document)}: d (jQuery, janela, documento)}) (function (d, l, j, q) {function t (a, b, c) {var e = b + "-" + c; se (n [e]) retorna n [e]; para (var d = [], a = a.cell (b, c) .node (). childNodes , b = 0, c = a.length; b <c; b ++) d.push (a [b]); return n [e] = d} função r (a, b, d) {var e = b +
    "-" + d; se (n [e]) {para (var a = célula. (b, d) .node (), d = n [e] [0] .parentNode.childNodes, b = [] , f = 0, g = comprimento d; f <g; f ++) b.push (d [f]); d = 0; para (f = comprimento b; d <f; d ++) a.appendChild (b [d]); n [e] = q}} var o = d.fn.dataTable, i = função (a, b) {if (! o.versionCheck ||! o.versionCheck ("1.10.10") ) throw "DataTables Responsive requer DataTables 1.10.10 ou mais recente"; this.s = {dt: new o.Api (a), colunas: [], current: []}; this.s.dt.settings () [ 0] .responsive || (b && "string" === tipo de b.detalhes? B.details = {type: b.details}: b &&! 1 === b.detalhes? B.details = {type:! 1 }:
    b &&! 0 === b.detalhes && (b.detalhes = {type: "inline"}), this.c = d.extend (! 0, {}, i.defaults, o.defaults.responsive, b), a.responsive = this, this._constructor ())}; d.extend (i.prototype, {_ construtor: function () {var a = this, b = this.s.dt, c = b.settings () [ 0], e = d (l) .width (); b.settings () [0] ._ responsivo = isso; d (l) .on ("redimensionamento.dtr orientacaocambicao.dtr", o.util.trottle (function () {var b = d (l) .width (); b! == e && (a._resize (), e = b)})); c.oApi._fnCallbackReg (c, "aoRowCreatedCallback", função (e ) {- 1! == d.inArray (! 1, ascendente) && d ("> td,> th",
    e) .each (função (e) {e = b.column.index ("toData", e) ;! 1 === ascurrent [e] && d (this) .css ("display", "none")} )}); b.on ("destroy.dtr", function () {b.off (". dtr"); d (b.table (). body ()). off (". dtr"); d (l) .off ("redimensionar.dtr orientacaocambica.dtr"); d.each (ascurrent, function (b, e) {! 1 === e && a._setColumnVis (b,! 0)})}); isto. c.breakpoints.sort (function (a, b) {return a.width <b.width? 1: a.width> b.width? -1: 0}); this._classLogic (); this._resizeAuto () ; c = this.c.details;! 1! == c.type && (a._detailsInit (), b.on ("column-visible.dtr", function () {a._timer &&
clearTimeout (a._timer); a._timer = setTimeout (function () {a._timer = null; a._classLogic (); a._resizeAuto (); a._resize (); a._redrawChildren ()}, 100) }), b.on ("draw.dtr", function () {a._redrawChildren ()}), d (b.table (). node ()). addClass ("dtr -" + c.type)) ; b.on ("column-reorder.dtr", function () {a._classLogic (); a._resizeAuto (); a._resize ()}); b.on ("column-sizing.dtr", function () {a._resizeAuto (); a._resize ()}); b.on ("preXhr.dtr", função () {var e = []; b.rows (). every (function () {this .child.isShown () && e.push (this.id (true))}); b.one ("draw.dtr",
    function () {a._resizeAuto (); a._resize (); b.rows (e) .every (function () {a._detailsDisplay (this, false)})})}); b.on ("init .dtr ", function () {a._resizeAuto (); a._resize (); d.inArray (false, ascurrent) && b.columns.adjust ()}); this._resize ()}, _ columnsVisiblity: function (a ) {var b = this.s.dt, c = this.s.columns, e, f, g = c.map (função (a, b) {return {columnIdx: b, prioridade: a.priority}}) .sort (função (a, b) {retornar a.priority! == b.priority? a.priority-b.priority: a.columnIdx-b.columnIdx}), h = d.map (c, function (e , c) {return! 1 === b.column (c) .visible ()?
    "não visível": e.auto && null === e.minWidth?! 1:! 0 === e.auto?"-":-1!==d.inArray(a,e.includeIn)}), m = 0; e = 0; para (f = h.length; e <f; e ++)! 0 === h [e] && (m + = c [e] .minWidth); e = b.settings () [0] .oScroll; e = e.sY || e.sX? E.iBarWidth: 0; m = b.table (). Container (). OffsetWidth-em; e = 0; for (f = h.length ; e <f; e ++) c [e] .control && (m- = c [e] .minWidth); var s =! 1; e = 0; para (f = comprimento de g; e <f; e ++) { var k = g [e] .columnIdx; "-" === h [k] && (! c [k] .controle && c [k] .minWidth) && (s || 0> mc [k] .minWidth? ( s =! 0, h [k] =! 1): h [k] =! 0, m- = c [k] .minWidth)} g =! 1; e = 0; para (f = comprimento; e <f; e ++) if (! c [e] .control &&
    ! c [e] .nunca &&! 1 === h [e]) {g =! 0; break} e = 0; para (f = c.length; e <f; e ++) c [e] .control && ( h [e] = g), "não visível" === h [e] && (h [e] =! 1); - 1 === d.inArray (! 0, h) && (h [0 ] =! 0); return h}, _ classLogic: function () {var a = this, b = this.c.breakpoints, c = this.s.dt, e = c.columns (). Eq (0). map (function (a) {var b = this.column (a), e = b.header (). className, a = c.settings () [0] .aoColumns [a] .responsivePriority; a === q && (b = d (b.header ()). data ("priority"), a = b! == q? 1 * b: 1E4); retorne {className: e, includeIn: [], auto:! 1, controle:! 1, nunca: e.match (/ \ bnever \ b /) ?! 0:! 1, prioridade: a}}),
    f = função (a, b) {var c = e [a] .includeIn; -1 === d.inArray (b, c) && c.push (b)}, g = função (d, c, g, k) {if (g) if ("max -" === g) {k = a._ encontrar (c) .width; c = 0; for (g = b.length; c <g; c ++) b [ c] .width <= k && f (d, b [c] .name)} else if ("min -" === g) {k = a._find (c) .width; c = 0; for (g = b.length; c <g; c ++) b [c] .width> = k && f (d, b [c] .name)} else {if ("not -" === g) {c = 0; for ( g = b.length; c <g; c ++) - 1 === b [c] .name.indexOf (k) && f (d, b [c] .name)}} else e [d] .includeIn.push (c)}; e.each (function (a, e) {for (var c = a.className.split ("")), f =! 1, i = 0, l = comprimento c; i <l; i ++) {var j = d.trim (c [i]);
    if ("all" === j) {f =! 0; a.includeIn = d.map (b, função (a) {retorne a.name}); return} if ("none" === j | | a.never) {f =! 0; return} if ("control" === j) {f =! 0; a.control =! 0; return} d.each (b, function (a, b) {var d = b.name.split ("-"), c = j.match (RegExp ("(min \\ - | max \\ - | não \\ -)? (" + d [0] + " ) (\\ - [_ a-zA-Z0-9])? ")); c && (f =! 0, c [2] === d [0] && c [3] ===" - "+ d [1]? G (e, b.name, c [1], c [2] + c [3]): c [2] === d [0] &&! C [3] && g (e, b .name, c [1], c [2]))})} f || (a.auto =! 0)}); this.s.columns = e}, _ detailsDisplay: function (a, b) {var c = this, e = this.s.dt, f = this.c.details; if (f &&! 1! == f.type) {var g =
    f.display (a, b, function () {retorna f.renderer (e, a [0], c._detalhesObj (a [0]))}); (! 0 === g ||! 1 == = g) && d (e.table (). node ()). triggerHandler ("responsive-display.dt", [e, a, g, b])}}, _ detailsInit: function () {var a = this, b = this.s.dt, c = this.c.details; "inline" === c.type && (c.target = "td: primeiro filho, th: primeiro filho"); b.on (" draw.dtr ", function () {a._tabIndexes ()}); a._tabIndexes (); d (b.table (). body ()). on (" keyup.dtr "," td, th ", function (a) {a.keyCode === 13 && d (this) .data ("dtr-keyboard") &&d (this) .click ()}); var e = c.target; d (b.table (). body ()). on ("click.dtr mousedown.dtr mouseup.dtr",
    "string" === tipo de e? e: "td, th", função (c) {if (d (b.table (). node ()). hasClass ("collapsed") && d.inArray (d (this ) .closest ("tr"). get (0), b.rows (). nós (). toArray ())! == - 1) {if (tipo de e === "número") {var g = e <0? b.columns (). eq (0) .length + e: e; if (b.cell (this) .index (). column! == g) return} g = b.row (d ( this) .closest ("tr")); c.type === "clique"? a._detailsDisplay (g, false): c.type === "mousedown"? d (this) .css ("outline" , "none"): c.type === "mouseup" && d (this) .blur (). css ("outline", ""))}})}, _ detailsObj: function (a) {var b = this, c = this.s.dt; retorna d.map (this.s.columns,
    função (e, d) {if (! e.never &&! e.control) return {title: c.settings () [0] .aoColumns [d] .sTitle, data: c.cell (a, d) .render (bcorthogonal), oculto: c.column (d) .visible () &&! bscurrent [d], columnIndex: d, rowIndex: a}})}, _ find: function (a) {for (var b = this.c .breakpoints, c = 0, e = b.length; c <e; c ++) if (b [c] .name === a) return b [c]}, _ redrawChildren: function () {var a = this, b = this.s.dt; b.rows ({page: "current"}). iterador ("linha", função (c, e) {b.row (e); a._detailsDisplay (b.row (e ) ,! 0)})}, _ redimensionar: function () {var a = isto, b = this.s.dt, c = d (l) .width (),
    e = this.c.breakpoints, f = e [0] .name, g = this.s.columns, h, m = this.s.current.slice (); for (h = e.length-1; 0 <= h; h -) if (c <= e [h] .width) {f = e [h] .name; break} var i = this._columnsVisiblity (f); this.s.current = i; e =! 1; h = 0; para (c = g.length; h <c; h ++) if (! 1 === i [h] &&! g [h] .nunca &&! g [h] .controle &&! 1 ===! B.column (h) .visible ()) {e =! 0; break} d (b.table (). Node ()). ToggleClass ("recolhido", e); var k =! 1, j = 0; b.columns (). Eq (0) .each (function (b, c) {! 0 === i [c] && j ++; i [c]! == m [c] && ( k =! 0, a._setColumnVis (b, i [c]))}); k && (this._redrawChildren (), d (b.table (). node ()). trigger ("responsive-resize.dt" ,
    [b, this.s.current]), 0 === b.page.info (). recordsDisplay && d ("td", b.table (). body ()). eq (0) .attr ("colspan" , j))}, _ resizeAuto: function () {var a = this.s.dt, b = this.s.columns; if (this.c.auto && - 1! == d.inArray (! 0, d. map (b, function (a) {return a.auto}))) {d.isEmptyObject (n) || d.each (n, function (b) {b = b.split ("-"); r ( a, 1 * b [0], 1 * b [1])}); a.table (). node (); var c = a.table (). node (). cloneNode (! 1), e = (a.table (). header (). cloneNode (! 1)). appendTo (c), f = d (a.table (). body ()). clone (! 1,! 1) .empty ( ) .appendTo (c), g = a.columns (). header (). filter (function (b) {retorna a.column (b) .visible ()}). para $ (). clone (! 1) .css ("exibição",
    "célula da tabela"). css ("min-width", 0); d (f) .append (d (linhas ({page: "current"}). nós ()). clone (! 1) ) .find ("th, td"). css ("display", ""); if (f = a.table (). rodapé ()) {var f = d (f.cloneNode (! 1)). appendTo (c), h = a.columns (). footer (). filter (function (b) {retorna a.column (b) .visible ()}). para $ (). clone (! 1) .css ("display", "table-cell"); d ("<tr />"). append (h) .appendTo (f)} d ("<tr />"). append (g) .appendTo (e ); "inline" === this.c.details.type && d (c) .addClass ("dtr-inline recolhido"); d (c) .find ("[name]"). removeAttr ("name"); d (c) .css ("posição", "relativo");
    c = d ("<div />"). css ({width: 1, height: 1, overflow: "hidden", clear: "both"}). append (c); c.insertBefore (a.table ( ) .node ()); g.each (function (c) {c = a.column.index ("fromVisible", c); b [c] .minWidth = this.offsetWidth || 0}); c.remove ()}}, _ setColumnVis: function (a, b) {var c = this.s.dt, e = b? "": "none"; d (c.column (a) .header ()). css ( "display", e); d (c.column (a) .footer ()). css ("display", e); c.column (a) .nodes (). a $ (). css ("display ", e); d.isEmptyObject (n) || c.cells (null, a) .indexes (). each (function (a) {r (c, a.row, a.column)})}, _ tabIndexes : function () {var a =
    this.s.dt, b = a.cells ({page: "current"}). nós (). a $ (), c = a.settings () [0], e = this.c.details.target ; b.filter ("[data-dtr-keyboard]"). removeData ("[data-dtr-keyboard]"); "number" === tipo de e? a.cells (null, e, {page: " current "}). nós (). para $ (). attr (" tabIndex ", c.iTabIndex) .data (" dtr-keyboard ", 1) :(" td: primeiro filho, th: primeiro filho " === e && (e = "> td: primeiro filho,> th: primeiro filho"), d (e, a.rows ({page: "current"}). nós ()). attr ("tabIndex ", c.iTabIndex) .data (" dtr-keyboard ", 1))}}); i.breakpoints = [{name:" desktop ", width: Infinity}, {name:" tablet-l ",
    width: 1024}, {name: "tablet-p", width: 768}, {name: "mobile-l", width: 480}, {name: "mobile-p", width: 320}]; i. display = {childRow: function (a, b, c) {if (b) {if (d (a.node ()). hasClass ("parent")) retorna a.child (c (), "child") .show () ,! 0} else {if (a.child.isShown ()) retorna a.child (! 1), d (a.node ()). removeClass ("parent") ,! 1; a. filho (c (), "filho"). show (); d (a.node ()). addClass ("pai"); return! 0}}, childRowImmediate: function (a, b, c) {if ( ! b && a.child.isShown () ||! a.responsive.hasHidden ()) retorna a.child (! 1), d (a.node ()). removeClass ("parent"),
        ! 1; a.child (c (), "child"). Show (); d (a.node ()). AddClass ("parent"); return! 0}, modal: function (a) {return function (b, c, e) {if (c) d ("div.dtr-modal-content"). empty (). append (e ()); else {var f = function () {g.remove () ; d (j) .off ("keypress.dtr")}, g = d ('<div class = "dtr-modal" />'). append (d ('<div class = "dtr-modal-display "/>').append(d('<div class =" dtr-modal-content "/> '). append (e ())). append (d (' <div class =" dtr-modal-close "> & times; </div> ') .click (function () {f ()}))). append (d (' <div class =" dtr-modal-background "/> '). clique em (function ( ) {f ()})). appendTo ("body");
        d (j) .on ("keyup.dtr", função (a) {27 === a.keyCode && (a.stopPropagation (), f ())})} a && a.header && d ("div.dtr-modal- conteúdo "). prepend (" <h2> "+ a.header (b) +" </h2> ")}}}; var n = {}; i.renderer = {listHiddenNodes: function () {return function ( a, b, c) {var e = d ('<ul data-dtr-index = "' + b + '" class = "dtr-details" />'), f =! 1; d.each (c, função (b, c) {c.hidden && (d ('<li data-dtr-index = "' + c.columnIndex + '" data-dt-row = "' + c.rowIndex + '" data-dt-column = "'+ c.columnIndex +'"> <span class = "dtr-title"> '+ c.title + "</span> </li>") .append (d (' <span class = "dtr-data" />').append(t(a,
        c.rowIndex, c.columnIndex)). appendTo (e), f =! 0)}); return f? e:! 1}}, listHidden: function () {função de retorno (a, b, c) { return (a = d.map (c, function (a) {return a.hidden? '<li data-dtr-index = "' + a.columnIndex + '" data-dt-row = "' + a.rowIndex + ' "data-dt-column =" '+ a.columnIndex +' "> <span class =" dtr-title "> '+ a.title +' </span> <span class =" dtr-data "> '+ a. data + "</span> </li>": ""}). join (""))? d ('<ul data-dtr-index = "' + b + '" class = "dtr-details" /> ') .append (a) :! 1}}, tableAll: function (a) {a = d.extend ({tableClass: ""}, a); função de retorno (b,
        c, e) {b = d.map (e, função (a) {return '<tr data-dt-row = "' + a.rowIndex + '" data-dt-column = "' + a.columnIndex + '" > <td> '+ a.title + ": </td> <td>"+a.data+"</td> </tr>"}). join (""); return d (' <table class = "'+ a.tableClass +' dtr-details" width = "100%" /> '). append (b)}}}; i.defaults = {pontos de interrupção: i.breakpoints, auto:! 0, detalhes: {display : i.display.childRow, renderizador: i.renderer.listHidden (), destino: 0, tipo: "inline"}, ortogonal: "display"}; var p = d.fn.dataTable.Api; p.register ( "responsive ()", function () {retorne isso}); p.register ("responsive.index ()",
    function (a) {a = d (a); return {column: a.data ("dtr-index"), linha: a.parent (). data ("dtr-index")}}); p.register ("responsive.rebuild ()", function () {retorna this.iterator ("table", function (a) {a._responsive && a._responsive._classLogic ()})}); p.register ("responsive.recalc ( ) ", function () {retorna this.iterator (" table ", function (a) {a._responsive && (a._responsive._resizeAuto (), a._responsive._resize ())})}); p.register ( "responsive.hasHidden ()", function () {var a = this.context [0]; retorna a._responsive? -1! == d.inArray (! 1, a._responsive.s.current):
    ! 1}); p.registerPlural ("column (). ResponsiveHidden ()", "column (). ResponsiveHidden ()", function () {retorna this.iterator ("column", function (a, b) {return a._responsive? a._responsive.s.current [b] :! 1}, 1)}); i.version = "2.2.3"; d.fn.dataTable.Responsive = i; d.fn.DataTable. Responsivo = i; d (j) .on ("preInit.dt.dtr", função (a, b) {if ("dt" === a.namespace && (d (b.nTable) .hasClass ("responsivo" ) || d (b.nTable) .hasClass ("dt-responsive") || b.oInit.responsive || o.defaults.responsive)) {var c = b.oInit.responsive;! 1! == c && new i (b, d.isPlainObject (c)?
    c: {})}}); retorne i});